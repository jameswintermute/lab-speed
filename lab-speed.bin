#!/usr/bin/env bash
# lab-speed — rapid lab setup utility
# Copyright (C) 2025 James Wintermute
# Licensed under GNU GPLv3 (https://www.gnu.org/licenses/)
#
# This program comes with ABSOLUTELY NO WARRANTY.
#
# Expected layout (repo root = same directory as this script):
#   local/hosts.csv
#   local/credentials.txt   (or local/creds.txt)
#   files-to-copy/
#
# Backwards-compat also supported:
#   ./hosts.csv
#   ./creds.txt
#   ./credentials.txt
#
# v1.1.13:
#  - Adds connectivity pre-check with progress bar and concise summary
#  - Adds colorized log levels ([OK]/[INFO]/[WARN]/[ERROR]) to reduce “wall of errors”

set -Eeuo pipefail
IFS=$'\n\t'

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd -P)"
LOCAL_DIR="$SCRIPT_DIR/local"
FILES_DIR="$SCRIPT_DIR/files-to-copy"
REMOTE_DIR="/tmp/lab-speed"
SSH_CONNECT_TIMEOUT="${SSH_CONNECT_TIMEOUT:-7}"
CONNECT_CHECK_TIMEOUT="${CONNECT_CHECK_TIMEOUT:-5}"

# NEW: logs
LOGS_DIR="$SCRIPT_DIR/logs"
mkdir -p "$LOGS_DIR"
RUN_ID="$(date +%Y%m%d-%H%M%S)-$$"
RUN_LOG="$LOGS_DIR/lab-speed-$RUN_ID.log"

# Credential caches (populated from credentials file and/or prompts)
PASS_CACHE=""
USER_CACHE=""

# ───────────────────────── UI / Colors ─────────────────────────
if [[ -t 1 ]]; then
  CLR_MAG=$'\e[35m'
  CLR_RST=$'\e[0m'
  CLR_DIM=$'\e[2m'
  CLR_RED=$'\e[31m'
  CLR_YEL=$'\e[33m'
  CLR_GRN=$'\e[32m'
  CLR_CYN=$'\e[36m'
else
  CLR_MAG=""; CLR_RST=""; CLR_DIM=""; CLR_RED=""; CLR_YEL=""; CLR_GRN=""; CLR_CYN=""
fi

# ───────────────────────── ASCII BANNER (VERBATIM) ─────────────────────────
header() {
  clear
  printf "%b" "$CLR_MAG"
  printf "%s\n" " ╻  ┏━┓┏┓    ┏━┓┏━┓┏━╸┏━╸╺┳┓╻"
  printf "%s\n" " ┃  ┣━┫┣┻┓   ┗━┓┣━┛┣╸ ┣╸  ┃┃╹"
  printf "%s\n" " ┗━╸╹ ╹┗━┛   ┗━┛╹  ┗━╸┗━╸╺┻┛╹"
  printf "\n%s\n" "      A rapid lab setup utility"
  printf "\n%s\n" "      v1.1.13 - Dec 2025. James Wintermute"
  printf "%b\n" "$CLR_RST"
}

# ───────────────────────── Logging ─────────────────────────
log_info() { echo "${CLR_CYN}[INFO]${CLR_RST} $*" | tee -a "$RUN_LOG" >/dev/null; }
log_ok()   { echo "${CLR_GRN}[OK]${CLR_RST}   $*" | tee -a "$RUN_LOG" >/dev/null; }
log_warn() { echo "${CLR_YEL}[WARN]${CLR_RST} $*" | tee -a "$RUN_LOG" >/dev/null; }
log_err()  { echo "${CLR_RED}[ERROR]${CLR_RST} $*" | tee -a "$RUN_LOG" >/dev/null; }

log_file() { log_info "Run log: $RUN_LOG"; }

# ───────────────────────── Path resolution ─────────────────────────
resolve_file_any() {
  local n
  for n in "$@"; do
    if [[ -f "$SCRIPT_DIR/$n" ]]; then printf "%s" "$SCRIPT_DIR/$n"; return 0; fi
    if [[ -f "$LOCAL_DIR/$n" ]]; then printf "%s" "$LOCAL_DIR/$n"; return 0; fi
  done
  return 1
}

HOSTS_CSV="$(resolve_file_any hosts.csv || true)"
CREDS_FILE="$(resolve_file_any creds.txt credentials.txt || true)"

# Known hosts file: prefer the one you already keep in local/
KNOWN_HOSTS_FILE="$SCRIPT_DIR/.known_hosts"
if [[ -f "$LOCAL_DIR/known_hosts" ]]; then
  KNOWN_HOSTS_FILE="$LOCAL_DIR/known_hosts"
fi

# Optional dedicated keypair in local/
SSH_KEY=""
SSH_KEY_PUB=""
if [[ -f "$LOCAL_DIR/lab_speed_ed25519" ]]; then
  SSH_KEY="$LOCAL_DIR/lab_speed_ed25519"
  SSH_KEY_PUB="$LOCAL_DIR/lab_speed_ed25519.pub"
elif [[ -f "$LOCAL_DIR/lab-speed_ed25519" ]]; then
  SSH_KEY="$LOCAL_DIR/lab-speed_ed25519"
  SSH_KEY_PUB="$LOCAL_DIR/lab-speed_ed25519.pub"
fi

# ───────────────────────── SSH options ─────────────────────────
SSH_OPTS=(
  -o "ConnectTimeout=${SSH_CONNECT_TIMEOUT}"
  -o "ServerAliveInterval=10"
  -o "ServerAliveCountMax=2"
  -o "StrictHostKeyChecking=accept-new"
  -o "UserKnownHostsFile=$KNOWN_HOSTS_FILE"
)
if [[ -n "${SSH_KEY:-}" ]]; then
  SSH_OPTS+=( -i "$SSH_KEY" )
fi

# ───────────────────────── utils ─────────────────────────
on_err() {
  local ec=$?
  echo
  log_err "lab-speed failed (exit=$ec) at line ${BASH_LINENO[0]}: ${BASH_COMMAND}"
  log_file
  echo
  return "$ec"
}
trap on_err ERR

pause() { echo; read -r -p "Press Enter to return to menu..." _ || true; }

trim() { echo "${1:-}" | sed 's/^[[:space:]]\+//; s/[[:space:]]\+$//'; }
clean_host() { echo "${1:-}" | sed -e 's#^[a-zA-Z]\+://##' -e 's#/.*$##'; }

require_cmd() { command -v "$1" >/dev/null 2>&1 || { log_warn "Missing dependency: $1"; return 1; }; }

check_dependencies() {
  local missing=0
  for c in bash awk sed ssh rsync; do require_cmd "$c" || missing=1; done
  require_cmd sshpass || missing=1
  command -v timeout >/dev/null 2>&1 || true
  if [[ "$missing" -ne 0 ]]; then
    echo
    log_warn "Install missing packages (example Ubuntu/Debian):"
    echo "  sudo apt-get update && sudo apt-get install -y sshpass rsync openssh-client gawk"
    echo
  fi
  return "$missing"
}

dependency_status() {
  echo
  log_info "Dependency check:"
  local c ok=1
  for c in bash awk sed ssh rsync sshpass; do
    if command -v "$c" >/dev/null 2>&1; then log_ok "  $c"; else log_warn "  $c (missing)"; ok=0; fi
  done
  if command -v timeout >/dev/null 2>&1; then log_ok "  timeout (optional)"; else log_info "  timeout (optional, not installed)"; fi
  echo
  return $(( ok==1 ? 0 : 1 ))
}

validate_layout() {
  local bad=0
  if [[ -z "${HOSTS_CSV:-}" || ! -f "$HOSTS_CSV" ]]; then
    log_warn "hosts.csv not found. Expected one of:"
    log_warn "  $SCRIPT_DIR/hosts.csv"
    log_warn "  $LOCAL_DIR/hosts.csv"
    bad=1
  fi
  if [[ -z "${CREDS_FILE:-}" || ! -f "$CREDS_FILE" ]]; then
    log_warn "credentials file not found. Expected one of:"
    log_warn "  $SCRIPT_DIR/creds.txt"
    log_warn "  $SCRIPT_DIR/credentials.txt"
    log_warn "  $LOCAL_DIR/creds.txt"
    log_warn "  $LOCAL_DIR/credentials.txt"
    bad=1
  fi
  if [[ ! -d "$FILES_DIR" ]]; then
    log_warn "files-to-copy directory not found: $FILES_DIR"
    bad=1
  fi
  return "$bad"
}

# Parse credentials in a flexible way.
# Supports either:
#   1) single-line password (legacy)
#   2) SSH_PASS=... / PASSWORD=...
#   3) username=... password=... (your current format)
# Quoted values are supported: username="foo"
read_credentials() {
  USER_CACHE=""
  PASS_CACHE=""

  [[ -f "$CREDS_FILE" ]] || return 1

  # First try key/value format
  local u p
  u="$(awk -F= '
    function trim(s){ gsub(/^[ \t\r]+|[ \t\r]+$/, "", s); return s }
    /^[ \t\r]*#/ { next }
    /^[ \t\r]*$/ { next }
    {
      k=tolower(trim($1)); v=$0; sub(/^[^=]*=/, "", v); v=trim(v);
      gsub(/^"+|"+$/, "", v);
      gsub(/^'\''+|'\''+$/, "", v);
      if (k=="username" || k=="user" || k=="ssh_user") { print v; exit }
    }' "$CREDS_FILE" 2>/dev/null || true)"
  p="$(awk -F= '
    function trim(s){ gsub(/^[ \t\r]+|[ \t\r]+$/, "", s); return s }
    /^[ \t\r]*#/ { next }
    /^[ \t\r]*$/ { next }
    {
      k=tolower(trim($1)); v=$0; sub(/^[^=]*=/, "", v); v=trim(v);
      gsub(/^"+|"+$/, "", v);
      gsub(/^'\''+|'\''+$/, "", v);
      if (k=="ssh_pass" || k=="password" || k=="pass") { print v; exit }
    }' "$CREDS_FILE" 2>/dev/null || true)"

  u="$(trim "$u")"; p="$(trim "$p")"
  if [[ -n "$u" || -n "$p" ]]; then
    USER_CACHE="$u"
    PASS_CACHE="$p"
    [[ -n "$PASS_CACHE" ]] || return 1
    [[ -n "$USER_CACHE" ]] || return 1
    return 0
  fi

  # Fallback: legacy "first non-empty line is password"
  local line
  line="$(grep -m1 -v '^[[:space:]]*$' "$CREDS_FILE" 2>/dev/null | tr -d '\r' || true)"
  line="$(trim "$line")"
  [[ -n "$line" ]] || return 1

  case "$line" in
    SSH_PASS=*) PASS_CACHE="$(trim "${line#SSH_PASS=}")" ;;
    PASSWORD=*) PASS_CACHE="$(trim "${line#PASSWORD=}")" ;;
    *)          PASS_CACHE="$line" ;;
  esac

  # In legacy mode user must be provided elsewhere; require it.
  # We keep USER_CACHE empty to force prompt.
  [[ -n "$PASS_CACHE" ]] || return 1
  return 0
}

ensure_credentials() {
  # If already present, good.
  if [[ -n "${USER_CACHE:-}" && -n "${PASS_CACHE:-}" ]]; then
    return 0
  fi

  # Try file parse
  read_credentials >/dev/null 2>&1 || true

  # If we have both, stop.
  if [[ -n "${USER_CACHE:-}" && -n "${PASS_CACHE:-}" ]]; then
    return 0
  fi

  echo
  log_warn "Missing username/password in credentials file: ${CREDS_FILE:-<not set>}"

  # Prompt for username if missing
  if [[ -z "${USER_CACHE:-}" ]]; then
    read -r -p "Enter SSH username: " USER_CACHE || true
    USER_CACHE="$(trim "$USER_CACHE")"
  fi

  # Prompt for password if missing
  if [[ -z "${PASS_CACHE:-}" ]]; then
    local pass=""
    read -r -s -p "Enter SSH password (will not echo): " pass || true
    echo
    PASS_CACHE="$(trim "$pass")"
  fi

  if [[ -z "${USER_CACHE:-}" || -z "${PASS_CACHE:-}" ]]; then
    log_err "Username/password not provided. Aborting this action."
    return 1
  fi

  # Offer to save back in key/value format (non-legacy)
  if [[ -z "${CREDS_FILE:-}" ]]; then
    CREDS_FILE="$LOCAL_DIR/credentials.txt"
  fi
  read -r -p "Save username/password to $(basename "$CREDS_FILE") for this repo? (Y/n): " ans || true
  case "${ans:-Y}" in
    n|N) log_info "Credentials will be used for this run only." ;;
    *)
      mkdir -p "$(dirname "$CREDS_FILE")" 2>/dev/null || true
      {
        echo "# lab-speed credentials (chmod 600)"
        printf 'username="%s"\n' "$USER_CACHE"
        printf 'password="%s"\n' "$PASS_CACHE"
      } > "$CREDS_FILE"
      chmod 600 "$CREDS_FILE" 2>/dev/null || true
      log_ok "Saved credentials to $CREDS_FILE"
      ;;
  esac

  return 0
}

read_hosts() {
  # Output: target,user,function
  awk -F',' '
    function trim(s){ sub(/^[ \t\r]+/, "", s); sub(/[ \t\r]+$/, "", s); return s }
    function clean(s){
      s=trim(s);
      sub(/^[A-Za-z]+:\/\//, "", s);
      sub(/\/.*$/, "", s);
      return s
    }
    /^[ \t\r]*$/ { next }
    /^[ \t\r]*#/ { next }
    {
      c1=tolower(trim($1));
      # skip header rows (support host-url)
      if (c1=="host" || c1=="hostname" || c1=="hosturl" || c1=="host-url" || c1=="host_url") next

      if (NF >= 4) {
        hosturl = clean($1);
        extip   = clean($2);
        intip   = clean($3);
        func    = trim($4);
        user    = (NF>=5 ? trim($5) : "");
        target  = (extip != "" ? extip : hosturl);
        if (target != "") print target "," user "," func
      } else {
        h = clean($1); u = trim($2); f = trim($3);
        if (h != "") print h "," u "," f
      }
    }
  ' "$HOSTS_CSV"
}

ssh_target() {
  local host="$1" user="$2"
  user="$(trim "${user:-}")"
  if [[ -z "$user" ]]; then
    user="$USER_CACHE"
  fi
  printf "%s@%s" "$user" "$host"
}

progress_bar() {
  local ok="$1" done="$2" total="$3" label="$4"
  local width=22
  local filled=$(( done * width / (total==0?1:total) ))
  local empty=$(( width - filled ))
  local bar
  bar="$(printf "%0.s#" $(seq 1 "$filled") 2>/dev/null || true)"
  bar="${bar}$(printf "%0.s-" $(seq 1 "$empty") 2>/dev/null || true)"
  printf "\r[%s] %d/%d hosts checked OK — %s" "$bar" "$ok" "$total" "$label"
}

probe_host_ok() {
  local target="$1"

  # key-based check first (no prompts)
  if command -v timeout >/dev/null 2>&1; then
    timeout "${CONNECT_CHECK_TIMEOUT}"s ssh "${SSH_OPTS[@]}" -o BatchMode=yes -o PreferredAuthentications=publickey "$target" "true" >/dev/null 2>&1 && return 0
  else
    ssh "${SSH_OPTS[@]}" -o BatchMode=yes -o PreferredAuthentications=publickey "$target" "true" >/dev/null 2>&1 && return 0
  fi

  # password-based check next (requires creds)
  if [[ -n "${PASS_CACHE:-}" ]]; then
    if command -v timeout >/dev/null 2>&1; then
      SSHPASS="$PASS_CACHE" timeout "${CONNECT_CHECK_TIMEOUT}"s sshpass -e ssh "${SSH_OPTS[@]}" -o PreferredAuthentications=password -o PubkeyAuthentication=no "$target" "true" >/dev/null 2>&1 && return 0
    else
      SSHPASS="$PASS_CACHE" sshpass -e ssh "${SSH_OPTS[@]}" -o PreferredAuthentications=password -o PubkeyAuthentication=no "$target" "true" >/dev/null 2>&1 && return 0
    fi
  fi
  return 1
}

# ───────────────────────── actions ─────────────────────────
step_validate() {
  echo "[1/5] Validating inputs..."
  check_dependencies || return 1
  validate_layout || return 1
  if ! read_hosts | grep -q .; then
    log_warn "No usable hosts found in $HOSTS_CSV"
    return 1
  fi

  # Must have username+password for GO workflows (ssh-copy-id/rsync/prompt)
  ensure_credentials || return 1

  local n; n="$(read_hosts | wc -l | tr -d ' ')"
  log_ok "Parsed hosts: $n"
  log_ok "Credentials OK (username + password present)"
  log_ok "hosts.csv: $HOSTS_CSV"
  log_ok "creds    : $CREDS_FILE"
  log_ok "knownhost: $KNOWN_HOSTS_FILE"
  [[ -n "${SSH_KEY:-}" ]] && log_ok "ssh key  : $SSH_KEY"
  log_file
  return 0
}

step_connectivity_check() {
  echo "[2/5] Checking connectivity to server list..."
  # connectivity can still run with key-only, but we already have creds from validate in most flows
  ensure_credentials || true

  local lines total okcount done
  mapfile -t lines < <(read_hosts)
  total="${#lines[@]}"
  okcount=0
  done=0
  [[ "$total" -eq 0 ]] && { log_warn "No hosts to check."; return 1; }

  local line host user func target label
  for line in "${lines[@]}"; do
    host="$(trim "${line%%,*}")"
    user="$(trim "$(echo "$line" | awk -F',' '{print $2}')" )"
    func="$(trim "$(echo "$line" | awk -F',' '{print $3}')" )"
    target="$(ssh_target "$host" "$user")"
    label="${func:-host} — ${host}"

    if probe_host_ok "$target"; then okcount=$((okcount+1)); fi
    done=$((done+1))
    progress_bar "$okcount" "$done" "$total" "$label"
  done
  echo
  if [[ "$okcount" -eq "$total" ]]; then
    log_ok "Connectivity OK: ${okcount}/${total} hosts reachable."
  else
    log_warn "Connectivity partial: ${okcount}/${total} hosts reachable."
    log_warn "Proceeding anyway (failed hosts will be skipped in later steps)."
  fi
  return 0
}

step_install_ssh_key() {
  echo "[3/5] Installing SSH key to lab servers (ssh-copy-id)..."
  ensure_credentials || return 1

  if [[ -n "${SSH_KEY_PUB:-}" && -f "$SSH_KEY_PUB" ]]; then
    log_info "Using repo key: $SSH_KEY_PUB"
  else
    if [[ ! -f "$HOME/.ssh/id_rsa.pub" && ! -f "$HOME/.ssh/id_ed25519.pub" ]]; then
      log_info "No default SSH key found; generating ed25519 key..."
      ssh-keygen -t ed25519 -N "" -f "$HOME/.ssh/id_ed25519" >/dev/null
    fi
  fi

  local keyopt=()
  [[ -n "${SSH_KEY_PUB:-}" && -f "$SSH_KEY_PUB" ]] && keyopt=( -i "$SSH_KEY_PUB" )

  local line host user func target
  while IFS= read -r line; do
    host="$(trim "${line%%,*}")"
    user="$(trim "$(echo "$line" | awk -F',' '{print $2}')" )"
    func="$(trim "$(echo "$line" | awk -F',' '{print $3}')" )"
    target="$(ssh_target "$host" "$user")"

    log_info "ssh-copy-id -> ${func:-host} — $target"
    if sshpass -p "$PASS_CACHE" ssh-copy-id "${keyopt[@]}" -o StrictHostKeyChecking=accept-new -o UserKnownHostsFile="$KNOWN_HOSTS_FILE" "$target" >>"$RUN_LOG" 2>&1; then
      log_ok "Key installed on $target"
    else
      log_warn "Key install failed on $target (see log)"
    fi
  done < <(read_hosts)

  return 0
}

step_rsync_files() {
  echo "[4/5] RSYNC syncing files-to-copy -> ${REMOTE_DIR} ..."
  ensure_credentials || return 1

  local line host user func target
  while IFS= read -r line; do
    host="$(trim "${line%%,*}")"
    user="$(trim "$(echo "$line" | awk -F',' '{print $2}')" )"
    func="$(trim "$(echo "$line" | awk -F',' '{print $3}')" )"
    target="$(ssh_target "$host" "$user")"

    log_info "Preparing ${func:-host} — $target"
    if ! SSHPASS="$PASS_CACHE" sshpass -e ssh "${SSH_OPTS[@]}" "$target" "mkdir -p '$REMOTE_DIR'" >>"$RUN_LOG" 2>&1; then
      log_warn "Failed to create $REMOTE_DIR on $target (continuing)"
      continue
    fi

    log_info "RSYNC -> ${func:-host} — $target:$REMOTE_DIR"
    SSHPASS="$PASS_CACHE" sshpass -e rsync -az --delete --timeout=20 -e "ssh ${SSH_OPTS[*]}" "$FILES_DIR/" "$target:$REMOTE_DIR/" >>"$RUN_LOG" 2>&1 \
      && log_ok "Synced to $target" \
      || log_warn "RSYNC failed on $target (see log)"
  done < <(read_hosts)

  return 0
}

step_set_prompt() {
  echo "[5/5] Setting remote ~/.bash_profile prompt (PS1)..."
  ensure_credentials || return 1

  local line host user func target func_label
  while IFS= read -r line; do
    host="$(trim "${line%%,*}")"
    user="$(trim "$(echo "$line" | awk -F',' '{print $2}')" )"
    func="$(trim "$(echo "$line" | awk -F',' '{print $3}')" )"
    target="$(ssh_target "$host" "$user")"
    func_label="${func:-lab}"

    log_info "Setting PS1 on ${func_label} — $target"

    SSHPASS="$PASS_CACHE" sshpass -e ssh "${SSH_OPTS[@]}" "$target" "bash -lc '
      set -e
      PROFILE=~/.bash_profile
      START=\"# >>> lab-speed PS1 >>>\"
      END=\"# <<< lab-speed PS1 <<<\"
      PS1_EXPORT=\"export PS1=\\\"[\\\\u@\\\\[\\\\e[30;42m\\\\]${func_label}\\\\[\\\\e[0m\\\\]\\\\h \\\\W]\\\\\\$ \\\"\\\"
      touch \"\$PROFILE\"
      tmp=\"\$PROFILE.labspeed.\$\$\"
      awk -v s=\"\$START\" -v e=\"\$END\" '
        \$0==s {in=1; next}
        \$0==e {in=0; next}
        in==0 {print}
      ' \"\$PROFILE\" > \"\$tmp\"
      {
        echo \"\"
        echo \"\$START\"
        echo \"\$PS1_EXPORT\"
        echo \"\$END\"
      } >> \"\$tmp\"
      mv \"\$tmp\" \"\$PROFILE\"
    '" >>"$RUN_LOG" 2>&1 \
      && log_ok "Prompt set on $target" \
      || log_warn "Prompt update failed on $target (see log)"
  done < <(read_hosts)

  return 0
}

option_go() {
  step_validate || { log_warn "Validation failed."; return 0; }
  step_connectivity_check || { log_warn "Connectivity check failed (proceeding)."; }
  step_install_ssh_key || true
  step_rsync_files || true
  step_set_prompt || true
  log_ok "GO workflow complete."
  return 0
}

option_ssh() {
  step_validate || { log_warn "Validation failed."; return 0; }
  step_connectivity_check || true

  log_info "Choose a host to SSH into:"
  local i=0
  local -a hosts users funcs
  local line host user func
  while IFS= read -r line; do
    host="$(trim "${line%%,*}")"
    user="$(trim "$(echo "$line" | awk -F',' '{print $2}')" )"
    func="$(trim "$(echo "$line" | awk -F',' '{print $3}')" )"
    hosts+=("$host"); users+=("$user"); funcs+=("$func")
    # UI: function first, then IP (no username)
    printf "  %d) %-12s - %s\n" "$((i+1))" "${func:-HOST}" "$host"
    i=$((i+1))
  done < <(read_hosts)

  if [[ "${#hosts[@]}" -eq 0 ]]; then
    log_warn "No hosts found."
    return 0
  fi

  printf "Select host number: "
  local sel; IFS= read -r sel || true
  [[ "$sel" =~ ^[0-9]+$ ]] || { log_warn "Invalid selection."; return 0; }
  sel=$((sel-1))
  (( sel >= 0 && sel < ${#hosts[@]} )) || { log_warn "Invalid selection."; return 0; }

  local target; target="$(ssh_target "${hosts[$sel]}" "${users[$sel]}")"
  log_info "Connecting to ${funcs[$sel]:-HOST} — $target (keys preferred; password fallback)..."

  # Try key-based interactive ssh first
  if ssh "${SSH_OPTS[@]}" "$target"; then
    return 0
  fi

  # Fallback to password auth
  SSHPASS="$PASS_CACHE" sshpass -e ssh "${SSH_OPTS[@]}" -o PreferredAuthentications=password -o PubkeyAuthentication=no "$target"
  return 0
}

option_rsync() {
  step_validate || { log_warn "Validation failed."; return 0; }
  step_connectivity_check || true
  step_rsync_files || true
  log_ok "RSYNC run finished."
  return 0
}

option_show_hosts() {
  [[ -n "${HOSTS_CSV:-}" && -f "$HOSTS_CSV" ]] || { log_warn "hosts.csv not found"; return 0; }
  echo "---- $HOSTS_CSV ----"
  sed -n '1,200p' "$HOSTS_CSV"
  echo "--------------------"
  return 0
}

option_review_files() {
  [[ -d "$FILES_DIR" ]] || { log_warn "Missing: $FILES_DIR"; return 0; }
  echo "---- $FILES_DIR ----"
  (cd "$FILES_DIR" && find . -maxdepth 2 -type f -print | sed 's|^\./||' | sort)
  echo "--------------------"
  return 0
}

option_deps() {
  dependency_status || true
  validate_layout || true
  if [[ -n "${HOSTS_CSV:-}" && -f "$HOSTS_CSV" ]]; then
    local n; n="$(read_hosts | wc -l | tr -d ' ')"
    log_info "Parsed hosts: $n"
  fi
  if [[ -n "${CREDS_FILE:-}" && -f "$CREDS_FILE" ]]; then
    if read_credentials >/dev/null 2>&1 && [[ -n "${USER_CACHE:-}" && -n "${PASS_CACHE:-}" ]]; then
      log_ok "Credentials file contains username + password."
    else
      log_warn "Credentials file missing/empty username/password."
    fi
  fi
  log_file
  return 0
}

option_cleanup() {
  echo
  echo "This will delete credentials file: ${CREDS_FILE:-<not found>}"
  read -r -p "Are you sure? (y/N): " ans || true
  case "${ans:-}" in
    y|Y)
      [[ -n "${CREDS_FILE:-}" ]] && rm -f -- "$CREDS_FILE"
      PASS_CACHE=""; USER_CACHE=""
      log_ok "Deleted credentials file."
      ;;
    *) log_info "Cleanup cancelled." ;;
  esac
  return 0
}

STARTUP_SHOWN=0
show_startup_checks_once() {
  if [[ "$STARTUP_SHOWN" -eq 1 ]]; then return 0; fi
  STARTUP_SHOWN=1
  dependency_status || true

  if [[ -n "${HOSTS_CSV:-}" && -f "$HOSTS_CSV" ]]; then
    local n; n="$(read_hosts | wc -l | tr -d ' ')"
    log_ok "hosts.csv found: $HOSTS_CSV (parsed hosts: $n)"
  else
    log_warn "hosts.csv not found yet (see option 5)."
  fi

  if [[ -n "${CREDS_FILE:-}" && -f "$CREDS_FILE" ]]; then
    if read_credentials >/dev/null 2>&1 && [[ -n "${USER_CACHE:-}" && -n "${PASS_CACHE:-}" ]]; then
      log_ok "credentials OK: $CREDS_FILE (username + password)"
    else
      log_warn "credentials incomplete: $CREDS_FILE (expected username + password)"
    fi
  else
    log_warn "credentials file not found (see expected layout)."
  fi

  log_file
  echo
}

show_menu() {
  header
  show_startup_checks_once
  cat <<'EOF'

### GO! - High Speed start ###
  1) GO! (install ssh key, RSYNC files to lab '/tmp', Console prompt)

### lab-connect ###
  2) SSH: To the servers in our hosts file (function-first list; keys preferred; password fallback)
  3) RSYNC: Rerun a file sync to lab servers '/tmp' directory (files-to-copy -> /tmp/lab-speed)

### Inspection ###
  4) Dependency check (manual)
  5) Show hosts.csv
  6) Review files-to-copy

### Clean-Up ###
  7) Clean Up, delete creds

  q) Quit
EOF
}

main_menu() {
  while true; do
    show_menu
    printf "Select an option: "
    local opt
    IFS= read -r opt || true
    case "${opt:-}" in
      1) option_go || true ;;
      2) option_ssh || true ;;
      3) option_rsync || true ;;
      4) option_deps || true ;;
      5) option_show_hosts || true ;;
      6) option_review_files || true ;;
      7) option_cleanup || true ;;
      q|Q) exit 0 ;;
      *) log_warn "Invalid choice: ${opt:-<blank>}"; sleep 1 ;;
    esac
    pause
  done
}

main_menu
