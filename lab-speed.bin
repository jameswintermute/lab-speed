#!/usr/bin/env bash
# lab-speed — rapid lab setup utility
# v1.2.0 — Feb 2026 — James Wintermute
#
# Changes from v1.1.20:
#   - sshpass -p → sshpass -e (password no longer visible in ps aux)
#   - SSH_OPTS array: single definition, used everywhere — no duplication
#   - GO! and RSYNC now run hosts in PARALLEL (background jobs) — major speed improvement
#   - Option 3 (RSYNC again) is now a lean rsync_only(), skips dep check
#   - ssh_menu() now uses sshpass -e for consistent no-prompt SSH
#   - read_hosts() finds CSV columns by header name, not hardcoded position
#   - IP validation guard in rsync_to_host()
#   - Log rotation: keeps last 20 logs
set -Eeuo pipefail

# ─────────────────────────────────── Colors ────────────────────────────────
CLR_MAG="\033[35m"; CLR_GRN="\033[32m"; CLR_RED="\033[31m"
CLR_YEL="\033[33m"; CLR_CYN="\033[36m"; CLR_RST="\033[0m"

# ─────────────────────────────────── Paths ─────────────────────────────────
ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd -P)"
LOCAL_DIR="$ROOT_DIR/local"
LOGS_DIR="$ROOT_DIR/logs"
FILES_DIR="$ROOT_DIR/files-to-copy"
HOSTS_FILE="$LOCAL_DIR/hosts.csv"
CREDS_FILE="$LOCAL_DIR/credentials.txt"
KNOWN_HOSTS_FILE="$ROOT_DIR/.known_hosts"
TARGET_DIR="/tmp/lab-speed"
mkdir -p "$LOCAL_DIR" "$LOGS_DIR" "$FILES_DIR"

RUN_TAG="$(date +%Y%m%d-%H%M%S)-$$"
RUN_LOG="$LOGS_DIR/lab-speed-$RUN_TAG.log"

# ─────────────────────────── SSH options (single definition) ───────────────
# Used by all ssh and rsync calls — change timeouts/options here only.
SSH_OPTS=(
  -o PreferredAuthentications=password
  -o PubkeyAuthentication=no
  -o NumberOfPasswordPrompts=1
  -o StrictHostKeyChecking=accept-new
  -o "UserKnownHostsFile=$KNOWN_HOSTS_FILE"
  -o ConnectTimeout=10
)

# ───────────────────────── ASCII BANNER ────────────────────────────────────
header() {
  clear
  printf "%b" "$CLR_MAG"
  printf "%s\n" " ╻  ┏━┓┏┓    ┏━┓┏━┓┏━╸┏━╸╺┳┓╻"
  printf "%s\n" " ┃  ┣━┫┣┻┓   ┗━┓┣━┛┣╸ ┣╸  ┃┃╹"
  printf "%s\n" " ┗━╸╹ ╹┗━┛   ┗━┛╹  ┗━╸┗━╸╺┻┛╹"
  printf "\n%s\n" "      A rapid lab setup utility"
  printf "\n%s\n" "      v1.2.0 - Feb 2026. James Wintermute"
  printf "%b\n" "$CLR_RST"
}

# ─────────────────────────────── Logging ───────────────────────────────────
log()      { printf "%b[%s]%b %s\n"   "$CLR_CYN" "$1" "$CLR_RST" "$2" | tee -a "$RUN_LOG"; }
log_ok()   { printf "%b[OK]%b %s\n"   "$CLR_GRN"      "$CLR_RST" "$1" | tee -a "$RUN_LOG"; }
log_warn() { printf "%b[WARN]%b %s\n" "$CLR_YEL"      "$CLR_RST" "$1" | tee -a "$RUN_LOG"; }
log_err()  { printf "%b[ERR]%b %s\n"  "$CLR_RED"      "$CLR_RST" "$1" | tee -a "$RUN_LOG"; }
die()      { log_err "$1"; exit 1; }

# ─────────────────────────── Trim whitespace + CR ──────────────────────────
trim() {
  local s="$1"
  s="${s//$'\r'/}"
  s="${s#${s%%[![:space:]]*}}"
  s="${s%${s##*[![:space:]]}}"
  printf "%s" "$s"
}

# ─────────────────────────────── Progress bar ──────────────────────────────
progress_bar() {
  local cur="$1" total="$2" label="$3"
  local width=22
  local filled=$(( (cur * width) / (total==0?1:total) ))
  local empty=$(( width - filled ))
  local bar
  bar="$(printf '%*s' "$filled" '' | tr ' ' '#')$(printf '%*s' "$empty" '' | tr ' ' '-')"
  printf "\r[%s] %d/%d %s" "$bar" "$cur" "$total" "$label"
}

# ─────────────────────────────── Log rotation ──────────────────────────────
rotate_logs() {
  # Keep the 20 most recent log files; silently remove older ones
  ls -t "$LOGS_DIR"/lab-speed-*.log 2>/dev/null | tail -n +21 | xargs rm -f --
}

# ────────────────────────────── Credentials ────────────────────────────────
ensure_creds() {
  if [[ ! -f "$CREDS_FILE" ]]; then
    mkdir -p "$LOCAL_DIR"
    cat >"$CREDS_FILE" <<'CRED'
# lab-speed credentials (chmod 600)
username=""
password=""
SSHPASS=""   # optional; if blank, password is used
CRED
    chmod 600 "$CREDS_FILE"
  fi

  # shellcheck disable=SC1090
  set +u
  source "$CREDS_FILE"
  set -u

  username="${username:-}"
  password="${password:-}"
  SSHPASS="${SSHPASS:-}"

  if [[ -z "${username}" || -z "${password}" ]]; then
    log "INFO" "Credentials missing; prompting and saving to $CREDS_FILE (chmod 600)."
    read -r -p "Lab username: " username
    read -r -s -p "Lab password: " password
    echo
    SSHPASS="${SSHPASS:-$password}"

    {
      echo "# lab-speed credentials (chmod 600)"
      printf 'username=%q\n' "$username"
      printf 'password=%q\n' "$password"
      printf 'SSHPASS=%q\n'  "$SSHPASS"
    } >"$CREDS_FILE"
    chmod 600 "$CREDS_FILE"
  fi

  # Ensure SSHPASS is always set — sshpass -e reads this env var
  [[ -z "${SSHPASS}" ]] && SSHPASS="$password"
  export SSHPASS
}

# ──────────────────────────────── Hosts file ───────────────────────────────
ensure_hosts() {
  if [[ ! -f "$HOSTS_FILE" ]]; then
    mkdir -p "$LOCAL_DIR"
    cat >"$HOSTS_FILE" <<'CSV'
host-url,external-ip,internal-ip,function
https://example-cm,1.2.3.4,10.0.0.1,Splunk-CM
CSV
  fi
}

# ──────────────────────────── Dependency check ─────────────────────────────
check_deps() {
  local missing=0
  for c in ssh rsync awk sed sshpass; do
    if ! command -v "$c" >/dev/null 2>&1; then
      log_err "Missing dependency: $c"
      missing=1
    else
      log_ok "$c"
    fi
  done
  if (( missing )); then
    echo
    log "INFO" "Install (Ubuntu/Debian): sudo apt-get update && sudo apt-get install -y openssh-client rsync gawk sed sshpass"
    exit 1
  fi
}

# ──────────────────────────────── Read hosts ───────────────────────────────
# Finds external-ip and function columns by header name — not hardcoded position.
# Supports both external-ip and external_ip header variants.
read_hosts() {
  awk -F',' '
    NR==1 {
      for (i=1; i<=NF; i++) {
        gsub(/\r/, "", $i)
        h = tolower($i)
        if (h == "external-ip" || h == "external_ip") ip_col = i
        if (h == "function") fn_col = i
      }
    }
    NR>1 && ip_col && fn_col {
      gsub(/\r/, "", $ip_col)
      gsub(/\r/, "", $fn_col)
      if ($ip_col != "") print $ip_col "," $fn_col
    }
  ' "$HOSTS_FILE" | sed '/^[[:space:]]*$/d'
}

# ───────────────────────────── Rsync to one host ───────────────────────────
rsync_to_host() {
  local ip="$1" func="$2"
  ip="$(trim "$ip")"; func="$(trim "$func")"

  # Guard: skip empty or obviously invalid IPs
  if [[ -z "$ip" ]]; then
    log_warn "Skipping ${func}: empty IP address"
    return 1
  fi
  if [[ ! "$ip" =~ ^[0-9]{1,3}(\.[0-9]{1,3}){3}$ ]]; then
    log_warn "${func}: '$ip' doesn't look like an IPv4 address — attempting anyway"
  fi

  # Single rsync call — --mkpath creates TARGET_DIR on the remote side,
  # eliminating the separate ssh mkdir connection (saves ~0.5–1s per host).
  # Falls back gracefully on older rsync that lacks --mkpath.
  if sshpass -e rsync -az --delete --mkpath \
      -e "ssh ${SSH_OPTS[*]}" \
      "$FILES_DIR/" "${username}@${ip}:$TARGET_DIR/" >/dev/null 2>&1; then
    return 0
  fi

  # Fallback for rsync < 3.2.3 without --mkpath: create dir first, then rsync
  sshpass -e ssh "${SSH_OPTS[@]}" "${username}@${ip}" \
    "mkdir -p '$TARGET_DIR'" >/dev/null 2>&1 || return 1

  sshpass -e rsync -az --delete \
    -e "ssh ${SSH_OPTS[*]}" \
    "$FILES_DIR/" "${username}@${ip}:$TARGET_DIR/" >/dev/null 2>&1
}

# ──────────────────── Parallel provision (GO! and RSYNC again) ─────────────
# Runs all rsync jobs concurrently. Results written to a temp dir so the
# final summary is accurate even with parallel output.
_run_parallel() {
  local label="$1"          # e.g. "GO" or "RSYNC"
  mapfile -t hosts < <(read_hosts)
  local total="${#hosts[@]}"
  (( total > 0 )) || die "No hosts found in $HOSTS_FILE"

  log "INFO" "$label starting — provisioning $total host(s) in parallel (→ $TARGET_DIR)"

  # Temp dir to collect per-host results
  local tmpdir
  tmpdir="$(mktemp -d)"
  trap 'rm -rf "$tmpdir"' RETURN

  # Launch all rsync jobs in the background
  local pids=()
  local line ip func
  for line in "${hosts[@]}"; do
    IFS=',' read -r ip func <<<"$line"
    ip="$(trim "$ip")"; func="$(trim "$func")"
    (
      if rsync_to_host "$ip" "$func"; then
        printf "ok:%s:%s\n" "$func" "$ip" >"$tmpdir/${func//\//_}.result"
      else
        printf "fail:%s:%s\n" "$func" "$ip" >"$tmpdir/${func//\//_}.result"
      fi
    ) &
    pids+=($!)
  done

  # Show a live "waiting" spinner while jobs run
  local done_count=0
  while (( done_count < total )); do
    done_count=0
    for f in "$tmpdir"/*.result 2>/dev/null; do
      [[ -f "$f" ]] && done_count=$(( done_count + 1 ))
    done
    progress_bar "$done_count" "$total" "syncing..."
    sleep 0.3
  done

  # Wait for all background jobs to finish
  for pid in "${pids[@]}"; do
    wait "$pid" 2>/dev/null || true
  done
  echo

  # Tally results
  local ok=0 fail=0
  for f in "$tmpdir"/*.result; do
    [[ -f "$f" ]] || continue
    local result; result="$(cat "$f")"
    case "$result" in
      ok:*)   ok=$(( ok + 1 )) ;;
      fail:*) fail=$(( fail + 1 ))
              local fhost; fhost="${result#fail:}"
              log_warn "${fhost%%:*} (${fhost##*:}) failed — check creds/ssh access" ;;
    esac
  done

  if (( fail == 0 )); then
    log_ok "$label complete — ${ok}/${total} hosts ready. RSYNC done."
  else
    log_warn "$label finished — ${ok}/${total} OK, ${fail} failed."
  fi
}

go_run() {
  ensure_hosts
  ensure_creds
  check_deps
  _run_parallel "GO"
  log "INFO" "Next: choose option 2 to open SSH sessions."
}

rsync_only() {
  # Skips ensure_creds / check_deps — assumes GO! was already run this session.
  # If SSHPASS is not exported yet (e.g. user jumped straight to option 3),
  # fall back to ensure_creds gracefully.
  if [[ -z "${SSHPASS:-}" ]]; then
    ensure_creds
  fi
  ensure_hosts
  _run_parallel "RSYNC"
}

# ─────────────────────────── Terminal launcher ─────────────────────────────
open_ssh_terminal() {
  local title="$1" cmd="$2"

  if command -v gnome-terminal >/dev/null 2>&1; then
    gnome-terminal --title="$title" -- bash -lc \
      "$cmd; echo; echo '[lab-speed] session ended'; read -r -p 'Press Enter to close...' _" \
      >/dev/null 2>&1 &
    return 0
  fi

  if command -v x-terminal-emulator >/dev/null 2>&1; then
    x-terminal-emulator -T "$title" -e bash -lc \
      "$cmd; echo; echo '[lab-speed] session ended'; read -r -p 'Press Enter to close...' _" \
      >/dev/null 2>&1 &
    return 0
  fi

  if command -v konsole >/dev/null 2>&1; then
    konsole --new-tab -p tabtitle="$title" -e bash -lc "$cmd" >/dev/null 2>&1 &
    return 0
  fi

  return 1
}

# ──────────────────────────────── SSH menu ─────────────────────────────────
ssh_menu() {
  ensure_hosts
  ensure_creds   # ensures SSHPASS is exported

  mapfile -t hosts < <(read_hosts)
  local total="${#hosts[@]}"
  (( total > 0 )) || die "No hosts found in $HOSTS_FILE"

  echo
  local i=0 line ip func
  for line in "${hosts[@]}"; do
    i=$(( i + 1 ))
    IFS=',' read -r ip func <<<"$line"
    ip="$(trim "$ip")"; func="$(trim "$func")"
    printf "%2d) %s  (%s)\n" "$i" "${func:-HOST}" "$ip"
  done

  echo
  read -r -p "Select host number (or q): " sel
  [[ "$sel" == "q" || "$sel" == "Q" ]] && return 0
  [[ "$sel" =~ ^[0-9]+$ ]] || { log_warn "Invalid selection"; return 0; }
  (( sel >= 1 && sel <= total )) || { log_warn "Selection out of range"; return 0; }

  IFS=',' read -r ip func <<<"${hosts[$(( sel - 1 ))]}"
  ip="$(trim "$ip")"; func="$(trim "$func")"

  # sshpass -e reads $SSHPASS (already exported by ensure_creds)
  # No password prompt — consistent with rsync behaviour
  local ssh_cmd
  ssh_cmd="sshpass -e ssh ${SSH_OPTS[*]} '${username}@${ip}'"

  if open_ssh_terminal "${func:-HOST}" "$ssh_cmd"; then
    log_ok "Opened SSH in a new terminal: ${func:-HOST} (${ip})"
    return 0
  fi

  log "INFO" "No GUI terminal found — opening SSH in this window."
  # shellcheck disable=SC2086
  eval "$ssh_cmd"
}

# ────────────────────────────────── Cleanup ────────────────────────────────
cleanup() {
  rm -f "$CREDS_FILE"
  log_ok "Deleted $CREDS_FILE"
}

# ──────────────────────────────── Main menu ────────────────────────────────
menu() {
  rotate_logs

  while true; do
    header
    echo "1) GO!  (install ssh key, RSYNC files)"
    echo "2) SSH  (open host session)"
    echo "3) RSYNC again"
    echo "4) Dependency check (manual)"
    echo "7) Clean Up (delete creds)"
    echo "q) Quit"
    echo
    read -r -p "Select an option: " opt
    case "$opt" in
      1) go_run;    read -r -p "Press Enter to return to menu..." _ ;;
      2) ssh_menu;  read -r -p "Press Enter to return to menu..." _ ;;
      3) rsync_only; read -r -p "Press Enter to return to menu..." _ ;;
      4) ensure_hosts; ensure_creds; check_deps; read -r -p "Press Enter to return to menu..." _ ;;
      7) cleanup;   read -r -p "Press Enter to return to menu..." _ ;;
      q|Q) exit 0 ;;
      *) log_warn "Invalid option"; sleep 0.5 ;;
    esac
  done
}

menu
