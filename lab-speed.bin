#!/usr/bin/env bash
# lab-speed — rapid lab setup utility
# Copyright (C) 2025 James Wintermute
# Licensed under GNU GPLv3 (https://www.gnu.org/licenses/)
#
# This program comes with ABSOLUTELY NO WARRANTY.
#
# Expected layout (repo root = same directory as this script):
#   local/hosts.csv
#   local/credentials.txt   (or local/creds.txt)
#   files-to-copy/
#
# Backwards-compat also supported:
#   ./hosts.csv
#   ./creds.txt
#   ./credentials.txt
#
# v1.1.13:
#  - Adds connectivity pre-check with progress bar and concise summary
#  - Adds colorized log levels ([OK]/[INFO]/[WARN]/[ERROR]) to reduce “wall of errors”
#
# v1.1.14 (local):
#  - Credentials file provides username+password (no hardcoded user)
#  - Function-first SSH menu (and tries to open new terminal window)
#  - Stronger RSYNC ssh option handling + per-host summary
#  - PS1 applied in .bashrc + .bash_profile sourcing

set -Eeuo pipefail
IFS=$'\n\t'

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd -P)"
LOCAL_DIR="$SCRIPT_DIR/local"
FILES_DIR="$SCRIPT_DIR/files-to-copy"
REMOTE_DIR="/tmp/lab-speed"
SSH_CONNECT_TIMEOUT="${SSH_CONNECT_TIMEOUT:-7}"
CONNECT_CHECK_TIMEOUT="${CONNECT_CHECK_TIMEOUT:-5}"

MAX_PARALLEL="${LABSPEED_PARALLEL:-4}"

LOGS_DIR="$SCRIPT_DIR/logs"; mkdir -p "$LOGS_DIR"
RUN_ID="$(date +%Y%m%d-%H%M%S)-$$"
RUN_LOG="$LOGS_DIR/lab-speed-$RUN_ID.log"

PASS_CACHE=""
USER_CACHE=""

declare -A ST_CONN ST_KEY ST_RSYNC ST_PS1

# ───────────────────────── UI / Colors ─────────────────────────
if [[ -t 1 ]]; then
  CLR_MAG=$'\e[35m'
  CLR_RST=$'\e[0m'
  CLR_DIM=$'\e[2m'
  CLR_RED=$'\e[31m'
  CLR_YEL=$'\e[33m'
  CLR_GRN=$'\e[32m'
  CLR_CYN=$'\e[36m'
else
  CLR_MAG=""; CLR_RST=""; CLR_DIM=""; CLR_RED=""; CLR_YEL=""; CLR_GRN=""; CLR_CYN=""
fi

# ───────────────────────── ASCII BANNER (VERBATIM) ─────────────────────────
header() {
  clear
  printf "%b" "$CLR_MAG"
  printf "%s\n" " ╻  ┏━┓┏┓    ┏━┓┏━┓┏━╸┏━╸╺┳┓╻"
  printf "%s\n" " ┃  ┣━┫┣┻┓   ┗━┓┣━┛┣╸ ┣╸  ┃┃╹"
  printf "%s\n" " ┗━╸╹ ╹┗━┛   ┗━┛╹  ┗━╸┗━╸╺┻┛╹"
  printf "\n%s\n" "      A rapid lab setup utility"
  printf "\n%s\n" "      v1.1.13 - Dec 2025. James Wintermute"
  printf "%b\n" "$CLR_RST"
}

# ───────────────────────── Logging ─────────────────────────
log_info() { echo "${CLR_CYN}[INFO]${CLR_RST} $*" | tee -a "$RUN_LOG" >/dev/null; }
log_ok()   { echo "${CLR_GRN}[OK]${CLR_RST}   $*" | tee -a "$RUN_LOG" >/dev/null; }
log_warn() { echo "${CLR_YEL}[WARN]${CLR_RST} $*" | tee -a "$RUN_LOG" >/dev/null; }
log_err()  { echo "${CLR_RED}[ERROR]${CLR_RST} $*" | tee -a "$RUN_LOG" >/dev/null; }
log_file() { log_info "Run log: $RUN_LOG"; }

on_err() {
  local ec=$?
  echo
  log_err "lab-speed failed (exit=$ec) at line ${BASH_LINENO[0]}: ${BASH_COMMAND}"
  log_file
  echo
  return "$ec"
}
trap on_err ERR

pause() { echo; read -r -p "Press Enter to return to menu..." _ || true; }
trim() { echo "${1:-}" | sed 's/^[[:space:]]\+//; s/[[:space:]]\+$//'; }
require_cmd() { command -v "$1" >/dev/null 2>&1 || { log_warn "Missing dependency: $1"; return 1; }; }

check_dependencies() {
  local missing=0
  for c in bash awk sed ssh rsync; do require_cmd "$c" || missing=1; done
  require_cmd sshpass || missing=1
  command -v timeout >/dev/null 2>&1 || true
  if [[ "$missing" -ne 0 ]]; then
    echo
    log_warn "Install missing packages (example Ubuntu/Debian):"
    echo "  sudo apt-get update && sudo apt-get install -y sshpass rsync openssh-client gawk"
    echo
  fi
  return "$missing"
}

dependency_status() {
  echo
  log_info "Dependency check:"
  local c ok=1
  for c in bash awk sed ssh rsync sshpass; do
    if command -v "$c" >/dev/null 2>&1; then log_ok "  $c"; else log_warn "  $c (missing)"; ok=0; fi
  done
  if command -v timeout >/dev/null 2>&1; then log_ok "  timeout (optional)"; else log_info "  timeout (optional, not installed)"; fi
  echo
  return $(( ok==1 ? 0 : 1 ))
}

resolve_file_any() {
  local n
  for n in "$@"; do
    [[ -f "$SCRIPT_DIR/$n" ]] && { printf "%s" "$SCRIPT_DIR/$n"; return 0; }
    [[ -f "$LOCAL_DIR/$n" ]] && { printf "%s" "$LOCAL_DIR/$n"; return 0; }
  done
  return 1
}

HOSTS_CSV="$(resolve_file_any hosts.csv || true)"
CREDS_FILE="$(resolve_file_any creds.txt credentials.txt || true)"

KNOWN_HOSTS_FILE="$SCRIPT_DIR/.known_hosts"
[[ -f "$LOCAL_DIR/known_hosts" ]] && KNOWN_HOSTS_FILE="$LOCAL_DIR/known_hosts"

SSH_KEY=""
SSH_KEY_PUB=""
if [[ -f "$LOCAL_DIR/lab_speed_ed25519" ]]; then
  SSH_KEY="$LOCAL_DIR/lab_speed_ed25519"; SSH_KEY_PUB="$LOCAL_DIR/lab_speed_ed25519.pub"
elif [[ -f "$LOCAL_DIR/lab-speed_ed25519" ]]; then
  SSH_KEY="$LOCAL_DIR/lab-speed_ed25519"; SSH_KEY_PUB="$LOCAL_DIR/lab-speed_ed25519.pub"
fi

SSH_OPTS=(
  -o "ConnectTimeout=${SSH_CONNECT_TIMEOUT}"
  -o "ServerAliveInterval=10"
  -o "ServerAliveCountMax=2"
  -o "StrictHostKeyChecking=accept-new"
  -o "UserKnownHostsFile=$KNOWN_HOSTS_FILE"
)
[[ -n "${SSH_KEY:-}" ]] && SSH_OPTS+=( -i "$SSH_KEY" )

ssh_cmd_string() {
  local s="ssh" o
  for o in "${SSH_OPTS[@]}"; do
    o="${o//\'/\'\\\'\'}"
    s+=" '$o'"
  done
  printf "%s" "$s"
}

validate_layout() {
  local bad=0
  if [[ -z "${HOSTS_CSV:-}" || ! -f "$HOSTS_CSV" ]]; then
    log_warn "hosts.csv not found. Expected one of:"
    log_warn "  $SCRIPT_DIR/hosts.csv"
    log_warn "  $LOCAL_DIR/hosts.csv"
    bad=1
  fi
  if [[ -z "${CREDS_FILE:-}" || ! -f "$CREDS_FILE" ]]; then
    log_warn "credentials file not found. Expected one of:"
    log_warn "  $SCRIPT_DIR/creds.txt"
    log_warn "  $SCRIPT_DIR/credentials.txt"
    log_warn "  $LOCAL_DIR/creds.txt"
    log_warn "  $LOCAL_DIR/credentials.txt"
    bad=1
  fi
  if [[ ! -d "$FILES_DIR" ]]; then
    log_warn "files-to-copy directory not found: $FILES_DIR"
    bad=1
  fi
  return "$bad"
}

read_credentials() {
  USER_CACHE=""; PASS_CACHE=""
  [[ -f "$CREDS_FILE" ]] || return 1

  local u p
  u="$(awk -F= '
    function trim(s){ gsub(/^[ \t\r]+|[ \t\r]+$/, "", s); return s }
    /^[ \t\r]*#/ { next } /^[ \t\r]*$/ { next }
    { k=tolower(trim($1)); v=$0; sub(/^[^=]*=/, "", v); v=trim(v);
      gsub(/^"+|"+$/, "", v); gsub(/^'\''+|'\''+$/, "", v);
      if (k=="username" || k=="user" || k=="ssh_user") { print v; exit } }' "$CREDS_FILE" 2>/dev/null || true)"
  p="$(awk -F= '
    function trim(s){ gsub(/^[ \t\r]+|[ \t\r]+$/, "", s); return s }
    /^[ \t\r]*#/ { next } /^[ \t\r]*$/ { next }
    { k=tolower(trim($1)); v=$0; sub(/^[^=]*=/, "", v); v=trim(v);
      gsub(/^"+|"+$/, "", v); gsub(/^'\''+|'\''+$/, "", v);
      if (k=="ssh_pass" || k=="password" || k=="pass") { print v; exit } }' "$CREDS_FILE" 2>/dev/null || true)"

  u="$(trim "$u")"; p="$(trim "$p")"
  USER_CACHE="$u"; PASS_CACHE="$p"
  [[ -n "$USER_CACHE" && -n "$PASS_CACHE" ]]
}

ensure_credentials() {
  if [[ -n "${USER_CACHE:-}" && -n "${PASS_CACHE:-}" ]]; then return 0; fi
  read_credentials >/dev/null 2>&1 || true
  if [[ -n "${USER_CACHE:-}" && -n "${PASS_CACHE:-}" ]]; then return 0; fi

  echo
  log_warn "Credentials incomplete in: ${CREDS_FILE:-<not set>}"
  if [[ -z "${USER_CACHE:-}" ]]; then
    read -r -p "Enter SSH username: " USER_CACHE || true
    USER_CACHE="$(trim "$USER_CACHE")"
  fi
  if [[ -z "${PASS_CACHE:-}" ]]; then
    local pass=""
    read -r -s -p "Enter SSH password (will not echo): " pass || true
    echo
    PASS_CACHE="$(trim "$pass")"
  fi
  [[ -n "$USER_CACHE" && -n "$PASS_CACHE" ]] || { log_err "Username/password not provided."; return 1; }

  if [[ -z "${CREDS_FILE:-}" ]]; then CREDS_FILE="$LOCAL_DIR/credentials.txt"; fi
  read -r -p "Save username/password to $(basename "$CREDS_FILE") for this repo? (Y/n): " ans || true
  case "${ans:-Y}" in
    n|N) log_info "Credentials will be used for this run only." ;;
    *)
      mkdir -p "$(dirname "$CREDS_FILE")" 2>/dev/null || true
      {
        echo "# lab-speed credentials (chmod 600)"
        printf 'username="%s"\n' "$USER_CACHE"
        printf 'password="%s"\n' "$PASS_CACHE"
      } > "$CREDS_FILE"
      chmod 600 "$CREDS_FILE" 2>/dev/null || true
      log_ok "Saved credentials to $CREDS_FILE"
      ;;
  esac
  return 0
}

read_hosts() {
  awk -F',' '
    function trim(s){ sub(/^[ \t\r]+/, "", s); sub(/[ \t\r]+$/, "", s); return s }
    function clean(s){ s=trim(s); sub(/^[A-Za-z]+:\/\//, "", s); sub(/\/.*$/, "", s); return s }
    /^[ \t\r]*$/ { next }
    /^[ \t\r]*#/ { next }
    {
      c1=tolower(trim($1))
      if (c1=="host" || c1=="hostname" || c1=="hosturl" || c1=="host-url" || c1=="host_url") next
      if (NF >= 4) {
        hosturl = clean($1); extip = clean($2); intip = clean($3); func = trim($4);
        user = (NF>=5 ? trim($5) : "");
        target = (extip != "" ? extip : hosturl);
        if (target != "") print target "," user "," func
      } else {
        h=clean($1); u=trim($2); f=trim($3);
        if (h != "") print h "," u "," f
      }
    }
  ' "$HOSTS_CSV"
}

ssh_target() {
  local host="$1" user="$2"
  user="$(trim "${user:-}")"
  [[ -z "$user" ]] && user="$USER_CACHE"
  printf "%s@%s" "$user" "$host"
}

sem_init() {
  SEM_FD=9
  local fifo
  fifo="$(mktemp -u)"
  mkfifo "$fifo"
  # shellcheck disable=SC2094
  exec {SEM_FD}<>"$fifo"
  rm -f "$fifo"
  local i
  for ((i=0;i<MAX_PARALLEL;i++)); do
    printf '.' >&${SEM_FD}
  done
}

sem_acquire() { local _; read -r -u ${SEM_FD} _; }
sem_release() { printf '.' >&${SEM_FD}; }
sem_close() { exec ${SEM_FD}>&- ${SEM_FD}<&-; }

progress_bar() {
  local ok="$1" done="$2" total="$3" label="$4"
  local width=22
  local filled=$(( done * width / (total==0?1:total) ))
  local empty=$(( width - filled ))
  local bar
  bar="$(printf "%0.s#" $(seq 1 "$filled") 2>/dev/null || true)"
  bar="${bar}$(printf "%0.s-" $(seq 1 "$empty") 2>/dev/null || true)"
  printf "\r[%s] %d/%d hosts checked OK — %s" "$bar" "$ok" "$total" "$label"
}

probe_host_ok() {
  local target="$1"
  if command -v timeout >/dev/null 2>&1; then
    timeout "${CONNECT_CHECK_TIMEOUT}"s ssh "${SSH_OPTS[@]}" -o BatchMode=yes -o PreferredAuthentications=publickey "$target" "true" >/dev/null 2>&1 && return 0
  else
    ssh "${SSH_OPTS[@]}" -o BatchMode=yes -o PreferredAuthentications=publickey "$target" "true" >/dev/null 2>&1 && return 0
  fi
  if [[ -n "${PASS_CACHE:-}" ]]; then
    if command -v timeout >/dev/null 2>&1; then
      SSHPASS="$PASS_CACHE" timeout "${CONNECT_CHECK_TIMEOUT}"s sshpass -e ssh "${SSH_OPTS[@]}" -o PreferredAuthentications=password -o PubkeyAuthentication=no "$target" "true" >/dev/null 2>&1 && return 0
    else
      SSHPASS="$PASS_CACHE" sshpass -e ssh "${SSH_OPTS[@]}" -o PreferredAuthentications=password -o PubkeyAuthentication=no "$target" "true" >/dev/null 2>&1 && return 0
    fi
  fi
  return 1
}

step_validate() {
  echo "[1/5] Validating inputs..."
  check_dependencies || return 1
  validate_layout || return 1
  read_hosts | grep -q . || { log_warn "No usable hosts found in $HOSTS_CSV"; return 1; }
  ensure_credentials || return 1

  local n; n="$(read_hosts | wc -l | tr -d ' ')"
  log_ok "Parsed hosts: $n"
  log_ok "Credentials OK (username + password present)"
  if [[ -d "$FILES_DIR" ]]; then
    local fcount; fcount="$(find "$FILES_DIR" -type f 2>/dev/null | wc -l | tr -d ' ')"
    [[ "$fcount" -eq 0 ]] && log_warn "files-to-copy is empty (RSYNC will create an empty destination)." || log_ok "files-to-copy contains $fcount file(s)"
  fi
  log_ok "hosts.csv: $HOSTS_CSV"
  log_ok "creds    : $CREDS_FILE"
  log_ok "knownhost: $KNOWN_HOSTS_FILE"
  [[ -n "${SSH_KEY:-}" ]] && log_ok "ssh key  : $SSH_KEY"
  log_file
  return 0
}

step_connectivity_check() {
  echo "[2/5] Checking connectivity to server list..."
  ensure_credentials || true

  local lines total okcount
  mapfile -t lines < <(read_hosts)
  total="${#lines[@]}"; okcount=0
  [[ "$total" -eq 0 ]] && { log_warn "No hosts to check."; return 1; }

  # Parallel mode: faster checks, summary after completion (no live progress bar).
  local tmpd; tmpd="$(mktemp -d)"
  sem_init

  local line host user func target
  for line in "${lines[@]}"; do
    host="$(trim "${line%%,*}")"
    user="$(trim "$(echo "$line" | awk -F',' '{print $2}')" )"
    func="$(trim "$(echo "$line" | awk -F',' '{print $3}')" )"
    target="$(ssh_target "$host" "$user")"

    sem_acquire
    {
      if probe_host_ok "$target"; then
        printf "OK\n" >"$tmpd/$host.conn"
      else
        printf "FAIL\n" >"$tmpd/$host.conn"
      fi
      sem_release
    } &
  done

  wait
  sem_close

  # Aggregate results
  for line in "${lines[@]}"; do
    host="$(trim "${line%%,*}")"
    if [[ -f "$tmpd/$host.conn" ]]; then
      ST_CONN["$host"]="$(cat "$tmpd/$host.conn" 2>/dev/null || echo FAIL)"
    else
      ST_CONN["$host"]="FAIL"
    fi
    [[ "${ST_CONN[$host]}" == "OK" ]] && okcount=$((okcount+1))
  done
  rm -rf "$tmpd" 2>/dev/null || true

  if [[ "$okcount" -eq "$total" ]]; then
    log_ok "Connectivity OK: ${okcount}/${total} hosts reachable. (parallel=${MAX_PARALLEL})"
  else
    log_warn "Connectivity partial: ${okcount}/${total} hosts reachable. (parallel=${MAX_PARALLEL})"
    log_warn "Proceeding anyway (failed hosts will be skipped in later steps)."
  fi
  return 0
}

step_install_ssh_key() {
  echo "[3/5] Installing SSH key to lab servers (ssh-copy-id)..."
  ensure_credentials || return 1

  if [[ -n "${SSH_KEY_PUB:-}" && -f "$SSH_KEY_PUB" ]]; then
    log_info "Using repo key: $SSH_KEY_PUB"
  else
    if [[ ! -f "$HOME/.ssh/id_rsa.pub" && ! -f "$HOME/.ssh/id_ed25519.pub" ]]; then
      log_info "No default SSH key found; generating ed25519 key..."
      ssh-keygen -t ed25519 -N "" -f "$HOME/.ssh/id_ed25519" >/dev/null
    fi
  fi

  local keyopt=()
  [[ -n "${SSH_KEY_PUB:-}" && -f "$SSH_KEY_PUB" ]] && keyopt=( -i "$SSH_KEY_PUB" )

  local tmpd; tmpd="$(mktemp -d)"
  sem_init

  local line host user func target
  while IFS= read -r line; do
    host="$(trim "${line%%,*}")"
    user="$(trim "$(echo "$line" | awk -F',' '{print $2}')" )"
    func="$(trim "$(echo "$line" | awk -F',' '{print $3}')" )"
    target="$(ssh_target "$host" "$user")"

    if [[ "${ST_CONN[$host]:-OK}" == "FAIL" ]]; then
      ST_KEY["$host"]="SKIP"
      continue
    fi

    sem_acquire
    {
      local hlog="$tmpd/$host.sshcopy.log"
      if sshpass -p "$PASS_CACHE" ssh-copy-id "${keyopt[@]}" \
          -o StrictHostKeyChecking=accept-new \
          -o UserKnownHostsFile="$KNOWN_HOSTS_FILE" \
          "$target" >"$hlog" 2>&1; then
        printf "OK\n" >"$tmpd/$host.key"
      else
        printf "FAIL\n" >"$tmpd/$host.key"
      fi
      sem_release
    } &
  done < <(read_hosts)

  wait
  sem_close

  # Merge per-host output into run log and set status
  while IFS= read -r line; do
    host="$(trim "${line%%,*}")"
    func="$(trim "$(echo "$line" | awk -F',' '{print $3}')" )"
    target="$(ssh_target "$host" "$(trim "$(echo "$line" | awk -F',' '{print $2}')" )")"

    if [[ "${ST_CONN[$host]:-OK}" == "FAIL" ]]; then
      ST_KEY["$host"]="SKIP"
      continue
    fi

    if [[ -f "$tmpd/$host.key" ]]; then
      ST_KEY["$host"]="$(cat "$tmpd/$host.key" 2>/dev/null || echo FAIL)"
    else
      ST_KEY["$host"]="FAIL"
    fi

    if [[ "${ST_KEY[$host]}" == "OK" ]]; then
      log_ok "Key installed on ${func:-HOST} — $target"
    else
      log_warn "Key install failed on ${func:-HOST} — $target (see log)"
    fi

    if [[ -f "$tmpd/$host.sshcopy.log" ]]; then
      {
        echo
        echo "----- ssh-copy-id ${func:-HOST} $target -----"
        sed -n '1,200p' "$tmpd/$host.sshcopy.log"
      } >>"$RUN_LOG"
    fi
  done < <(read_hosts)

  rm -rf "$tmpd" 2>/dev/null || true
  return 0
}

step_rsync_files() {
  echo "[4/5] RSYNC syncing files-to-copy -> ${REMOTE_DIR} ..."
  ensure_credentials || return 1

  local rsync_ssh; rsync_ssh="$(ssh_cmd_string)"
  log_info "RSYNC remote shell: $rsync_ssh"

  local line host user func target
  while IFS= read -r line; do
    host="$(trim "${line%%,*}")"
    user="$(trim "$(echo "$line" | awk -F',' '{print $2}')" )"
    func="$(trim "$(echo "$line" | awk -F',' '{print $3}')" )"
    target="$(ssh_target "$host" "$user")"

    if [[ "${ST_CONN[$host]:-OK}" == "FAIL" ]]; then ST_RSYNC["$host"]="SKIP"; continue; fi

    log_info "Preparing ${func:-HOST} — $target"
    if ! SSHPASS="$PASS_CACHE" sshpass -e ssh "${SSH_OPTS[@]}" "$target" "mkdir -p '$REMOTE_DIR'" >>"$RUN_LOG" 2>&1; then
      ST_RSYNC["$host"]="FAIL"; log_warn "Failed to create $REMOTE_DIR on $target (continuing)"; continue
    fi

    log_info "RSYNC -> ${func:-HOST} — $target:$REMOTE_DIR"
    if SSHPASS="$PASS_CACHE" sshpass -e rsync -az --delete --timeout=30 -e "$rsync_ssh" "$FILES_DIR/" "$target:$REMOTE_DIR/" >>"$RUN_LOG" 2>&1; then
      ST_RSYNC["$host"]="OK"; log_ok "Synced to $target"
    else
      ST_RSYNC["$host"]="FAIL"; log_warn "RSYNC failed on $target (see log)"
    fi
  done < <(read_hosts)
  return 0
}

step_set_prompt() {
  echo "[5/5] Setting remote ~/.bashrc + ~/.bash_profile prompt (PS1)..."
  ensure_credentials || return 1

  local line host user func target func_label
  while IFS= read -r line; do
    host="$(trim "${line%%,*}")"
    user="$(trim "$(echo "$line" | awk -F',' '{print $2}')" )"
    func="$(trim "$(echo "$line" | awk -F',' '{print $3}')" )"
    target="$(ssh_target "$host" "$user")"
    func_label="${func:-lab}"

    if [[ "${ST_CONN[$host]:-OK}" == "FAIL" ]]; then ST_PS1["$host"]="SKIP"; continue; fi

    log_info "Setting PS1 on ${func_label} — $target"
    SSHPASS="$PASS_CACHE" sshpass -e ssh "${SSH_OPTS[@]}" "$target" "bash -lc '
      set -e
      BRC=~/.bashrc
      BPF=~/.bash_profile
      START=\"# >>> lab-speed PS1 >>>\"
      END=\"# <<< lab-speed PS1 <<<\"
      PS1_EXPORT=\"export PS1=\\\"[\\\\u@\\\\[\\\\e[30;42m\\\\]${func_label}\\\\[\\\\e[0m\\\\]\\\\h \\\\W]\\\\\\$ \\\"\\\"

      touch \"\$BRC\" \"\$BPF\"

      if ! grep -qE \"(^|\\s)(source|\\.)\\s+~\\/.bashrc\" \"\$BPF\"; then
        echo \"\" >> \"\$BPF\"
        echo \"# lab-speed: ensure .bashrc is loaded\" >> \"\$BPF\"
        echo \"if [ -f ~/.bashrc ]; then . ~/.bashrc; fi\" >> \"\$BPF\"
      fi

      tmp=\"\$BRC.labspeed.\$\$\"
      awk -v s=\"\$START\" -v e=\"\$END\" '
        \$0==s {in=1; next}
        \$0==e {in=0; next}
        in==0 {print}
      ' \"\$BRC\" > \"\$tmp\"

      {
        echo \"\"
        echo \"\$START\"
        echo \"\$PS1_EXPORT\"
        echo \"\$END\"
      } >> \"\$tmp\"
      mv \"\$tmp\" \"\$BRC\"
    '" >>"$RUN_LOG" 2>&1 \
      && { ST_PS1["$host"]="OK"; log_ok "Prompt set on $target"; } \
      || { ST_PS1["$host"]="FAIL"; log_warn "Prompt update failed on $target (see log)"; }
  done < <(read_hosts)
  return 0
}

print_summary() {
  echo
  echo "────────── GO Summary ──────────" | tee -a "$RUN_LOG" >/dev/null
  printf "%-12s  %-15s  %-6s  %-6s  %-6s  %-6s\n" "FUNCTION" "HOST" "CONN" "KEY" "RSYNC" "PS1" | tee -a "$RUN_LOG" >/dev/null
  printf "%-12s  %-15s  %-6s  %-6s  %-6s  %-6s\n" "--------" "----" "----" "---" "-----" "---" | tee -a "$RUN_LOG" >/dev/null
  local line host func
  while IFS= read -r line; do
    host="$(trim "${line%%,*}")"
    func="$(trim "$(echo "$line" | awk -F',' '{print $3}')" )"
    printf "%-12s  %-15s  %-6s  %-6s  %-6s  %-6s\n" \
      "${func:-HOST}" "$host" \
      "${ST_CONN[$host]:-UNK}" "${ST_KEY[$host]:-UNK}" "${ST_RSYNC[$host]:-UNK}" "${ST_PS1[$host]:-UNK}" \
      | tee -a "$RUN_LOG" >/dev/null
  done < <(read_hosts)
  echo "────────────────────────────────" | tee -a "$RUN_LOG" >/dev/null
  log_file
}

option_go() {
  ST_CONN=(); ST_KEY=(); ST_RSYNC=(); ST_PS1=()
  step_validate || { log_warn "Validation failed."; return 0; }
  step_connectivity_check || { log_warn "Connectivity check failed (proceeding)."; }
  step_install_ssh_key || true
  step_rsync_files || true
  step_set_prompt || true
  print_summary
  log_ok "GO workflow complete."
  return 0
}

spawn_terminal_ssh() {
  local label="$1" target="$2"
  [[ -z "${DISPLAY:-}" ]] && return 1
  if command -v gnome-terminal >/dev/null 2>&1; then
    gnome-terminal --title="lab-speed: $label" -- bash -lc "ssh ${SSH_OPTS[*]} '$target'; echo; read -r -p 'Session ended. Press Enter to close...';" >/dev/null 2>&1 && return 0
  elif command -v x-terminal-emulator >/dev/null 2>&1; then
    x-terminal-emulator -T "lab-speed: $label" -e bash -lc "ssh ${SSH_OPTS[*]} '$target'; echo; read -r -p 'Session ended. Press Enter to close...';" >/dev/null 2>&1 && return 0
  elif command -v xterm >/dev/null 2>&1; then
    xterm -T "lab-speed: $label" -e bash -lc "ssh ${SSH_OPTS[*]} '$target'; echo; read -r -p 'Session ended. Press Enter to close...';" >/dev/null 2>&1 && return 0
  fi
  return 1
}

option_ssh() {
  step_validate || { log_warn "Validation failed."; return 0; }
  step_connectivity_check || true

  log_info "Choose a host to SSH into:"
  local i=0
  local -a hosts users funcs
  local line host user func
  while IFS= read -r line; do
    host="$(trim "${line%%,*}")"
    user="$(trim "$(echo "$line" | awk -F',' '{print $2}')" )"
    func="$(trim "$(echo "$line" | awk -F',' '{print $3}')" )"
    hosts+=("$host"); users+=("$user"); funcs+=("$func")
    printf "  %d) %-12s - %s\n" "$((i+1))" "${func:-HOST}" "$host"
    i=$((i+1))
  done < <(read_hosts)

  [[ "${#hosts[@]}" -gt 0 ]] || { log_warn "No hosts found."; return 0; }

  printf "Select host number: "
  local sel; IFS= read -r sel || true
  [[ "$sel" =~ ^[0-9]+$ ]] || { log_warn "Invalid selection."; return 0; }
  sel=$((sel-1))
  (( sel >= 0 && sel < ${#hosts[@]} )) || { log_warn "Invalid selection."; return 0; }

  local target; target="$(ssh_target "${hosts[$sel]}" "${users[$sel]}")"
  local label="${funcs[$sel]:-HOST} - ${hosts[$sel]}"

  if spawn_terminal_ssh "$label" "$target"; then
    log_ok "Opened new SSH terminal for $label"
    return 0
  fi

  log_info "Connecting to $label (keys preferred; password fallback)..."
  if ssh "${SSH_OPTS[@]}" "$target"; then return 0; fi
  SSHPASS="$PASS_CACHE" sshpass -e ssh "${SSH_OPTS[@]}" -o PreferredAuthentications=password -o PubkeyAuthentication=no "$target"
  return 0
}

option_rsync() {
  ST_RSYNC=()
  step_validate || { log_warn "Validation failed."; return 0; }
  step_connectivity_check || true
  step_rsync_files || true
  print_summary
  log_ok "RSYNC run finished."
  return 0
}

option_show_hosts() {
  [[ -n "${HOSTS_CSV:-}" && -f "$HOSTS_CSV" ]] || { log_warn "hosts.csv not found"; return 0; }
  echo "---- $HOSTS_CSV ----"
  sed -n '1,200p' "$HOSTS_CSV"
  echo "--------------------"
  return 0
}

option_review_files() {
  [[ -d "$FILES_DIR" ]] || { log_warn "Missing: $FILES_DIR"; return 0; }
  echo "---- $FILES_DIR ----"
  (cd "$FILES_DIR" && find . -maxdepth 2 -type f -print | sed 's|^\./||' | sort)
  echo "--------------------"
  return 0
}

option_deps() {
  dependency_status || true
  validate_layout || true
  [[ -n "${HOSTS_CSV:-}" && -f "$HOSTS_CSV" ]] && log_info "Parsed hosts: $(read_hosts | wc -l | tr -d ' ')"
  if [[ -n "${CREDS_FILE:-}" && -f "$CREDS_FILE" ]]; then
    if read_credentials >/dev/null 2>&1; then log_ok "Credentials file contains username + password."; else log_warn "Credentials file missing/empty username/password."; fi
  fi
  log_file
  return 0
}

option_cleanup() {
  echo
  echo "This will delete credentials file: ${CREDS_FILE:-<not found>}"
  read -r -p "Are you sure? (y/N): " ans || true
  case "${ans:-}" in
    y|Y)
      [[ -n "${CREDS_FILE:-}" ]] && rm -f -- "$CREDS_FILE"
      PASS_CACHE=""; USER_CACHE=""
      log_ok "Deleted credentials file."
      ;;
    *) log_info "Cleanup cancelled." ;;
  esac
  return 0
}

STARTUP_SHOWN=0
show_startup_checks_once() {
  [[ "$STARTUP_SHOWN" -eq 1 ]] && return 0
  STARTUP_SHOWN=1
  dependency_status || true

  if [[ -n "${HOSTS_CSV:-}" && -f "$HOSTS_CSV" ]]; then
    log_ok "hosts.csv found: $HOSTS_CSV (parsed hosts: $(read_hosts | wc -l | tr -d ' '))"
  else
    log_warn "hosts.csv not found yet (see option 5)."
  fi

  if [[ -n "${CREDS_FILE:-}" && -f "$CREDS_FILE" ]]; then
    if read_credentials >/dev/null 2>&1; then log_ok "credentials OK: $CREDS_FILE (username + password)"; else log_warn "credentials incomplete: $CREDS_FILE (expected username + password)"; fi
  else
    log_warn "credentials file not found (see expected layout)."
  fi

  log_file
  echo
}

show_menu() {
  header
  show_startup_checks_once
  cat <<'EOF'

### GO! - High Speed start ###
  1) GO! (install ssh key, RSYNC files to lab '/tmp', Console prompt)

### lab-connect ###
  2) SSH: To the servers in our hosts file (function-first list; opens new terminal if available)
  3) RSYNC: Rerun a file sync to lab servers '/tmp' directory (files-to-copy -> /tmp/lab-speed)

### Inspection ###
  4) Dependency check (manual)
  5) Show hosts.csv
  6) Review files-to-copy

### Clean-Up ###
  7) Clean Up, delete creds

  q) Quit
EOF
}

main_menu() {
  while true; do
    show_menu
    printf "Select an option: "
    local opt
    IFS= read -r opt || true
    case "${opt:-}" in
      1) option_go || true ;;
      2) option_ssh || true ;;
      3) option_rsync || true ;;
      4) option_deps || true ;;
      5) option_show_hosts || true ;;
      6) option_review_files || true ;;
      7) option_cleanup || true ;;
      q|Q) exit 0 ;;
      *) log_warn "Invalid choice: ${opt:-<blank>}"; sleep 1 ;;
    esac
    pause
  done
}

main_menu
